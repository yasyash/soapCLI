/* soapStub.h
   Generated by gSOAP 2.8.117 for test.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns	"urn:ReplicationApiService"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208117
# error "GSOAP VERSION 208117 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* test.h:193 */
#ifndef SOAP_TYPE_ns__ErrorCode
#define SOAP_TYPE_ns__ErrorCode (19)
/* ns:ErrorCode */
enum ns__ErrorCode {
	ns__ErrorCode__authoization_ok = 0,
	ns__ErrorCode__authoization_error = 1,
	ns__ErrorCode__connection_error = 2,
	ns__ErrorCode__query_error = 3,
	ns__ErrorCode__db_busy = 4
};
#endif

/* test.h:205 */
#ifndef SOAP_TYPE_ns__UserAccessRightCode
#define SOAP_TYPE_ns__UserAccessRightCode (20)
/* ns:UserAccessRightCode */
enum ns__UserAccessRightCode {
	ns__UserAccessRightCode__none = 0,
	ns__UserAccessRightCode__view = 1,
	ns__UserAccessRightCode__edit = 2,
	ns__UserAccessRightCode__delete_ = 3
};
#endif

/* test.h:216 */
#ifndef SOAP_TYPE_ns__MeasurementClasses
#define SOAP_TYPE_ns__MeasurementClasses (21)
/* ns:MeasurementClasses */
enum ns__MeasurementClasses {
	ns__MeasurementClasses__data = 0,
	ns__MeasurementClasses__alert = 1,
	ns__MeasurementClasses__hum_out = 2,
	ns__MeasurementClasses__nothing = 3
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns__BriefData;	/* test.h:159 */
class ns__ArrayOfBriefData;	/* test.h:161 */
class ns__StationInfo;	/* test.h:163 */
class ns__UnitInfo;	/* test.h:165 */
class ns__SensorInfo;	/* test.h:167 */
class ns__SensorData;	/* test.h:169 */
class ns__ArrayOfStationInfo;	/* test.h:171 */
class ns__ArrayOfSensorsInfo;	/* test.h:173 */
class ns__ArrayOfSensorData;	/* test.h:175 */
class ns__StInfo;	/* test.h:177 */
class ns__ArrayOfSensors;	/* test.h:179 */
struct ns__GetStationsResponse;	/* test.h:596 */
struct ns__GetStations;	/* test.h:662 */
struct ns__GetSensorsResponse;	/* test.h:673 */
struct ns__GetSensors;	/* test.h:748 */
struct ns__GetHistoricalDataBriefResponse;	/* test.h:759 */
struct ns__GetHistoricalDataBrief;	/* test.h:837 */

/* test.h:159 */
#ifndef SOAP_TYPE_ns__BriefData
#define SOAP_TYPE_ns__BriefData (8)
/* complex XML schema type 'ns:BriefData': */
class SOAP_CMAC ns__BriefData {
      public:
        /// Required element 'Time' of XML schema type 'xsd:string'
        std::string Time;
        /// Required element 'Value' of XML schema type 'xsd:double'
        double Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns__BriefData
        virtual long soap_type(void) const { return SOAP_TYPE_ns__BriefData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__BriefData, default initialized and not managed by a soap context
        virtual ns__BriefData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns__BriefData); }
      public:
        /// Constructor with default initializations
        ns__BriefData() : Time(), Value(), soap() { }
        virtual ~ns__BriefData() { }
        /// Friend allocator used by soap_new_ns__BriefData(struct soap*, int)
        friend SOAP_FMAC1 ns__BriefData * SOAP_FMAC2 soap_instantiate_ns__BriefData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:161 */
#ifndef SOAP_TYPE_ns__ArrayOfBriefData
#define SOAP_TYPE_ns__ArrayOfBriefData (9)
/* complex XML schema type 'ns:ArrayOfBriefData': */
class SOAP_CMAC ns__ArrayOfBriefData {
      public:
        /// Optional element 'BriefData' of XML schema type 'ns:BriefData'
        std::vector<ns__BriefData *> BriefData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns__ArrayOfBriefData
        virtual long soap_type(void) const { return SOAP_TYPE_ns__ArrayOfBriefData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ArrayOfBriefData, default initialized and not managed by a soap context
        virtual ns__ArrayOfBriefData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns__ArrayOfBriefData); }
      public:
        /// Constructor with default initializations
        ns__ArrayOfBriefData() : BriefData(), soap() { }
        virtual ~ns__ArrayOfBriefData() { }
        /// Friend allocator used by soap_new_ns__ArrayOfBriefData(struct soap*, int)
        friend SOAP_FMAC1 ns__ArrayOfBriefData * SOAP_FMAC2 soap_instantiate_ns__ArrayOfBriefData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:163 */
#ifndef SOAP_TYPE_ns__StationInfo
#define SOAP_TYPE_ns__StationInfo (10)
/* complex XML schema type 'ns:StationInfo': */
class SOAP_CMAC ns__StationInfo {
      public:
        /// Required element 'ID' of XML schema type 'xsd:string'
        std::string ID;
        /// Required element 'Code' of XML schema type 'xsd:int'
        int Code;
        /// Required element 'Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required element 'UpdatePeriod' of XML schema type 'xsd:int'
        int UpdatePeriod;
        /// Required element 'Place' of XML schema type 'xsd:string'
        std::string Place;
        /// Required element 'Latitude' of XML schema type 'xsd:float'
        float Latitude;
        /// Required element 'Longitude' of XML schema type 'xsd:float'
        float Longitude;
        /// Required element 'UserAccessRight' of XML schema type 'xsd:string'
        std::string UserAccessRight;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns__StationInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns__StationInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__StationInfo, default initialized and not managed by a soap context
        virtual ns__StationInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns__StationInfo); }
      public:
        /// Constructor with default initializations
        ns__StationInfo() : ID(), Code(), Name(), UpdatePeriod(), Place(), Latitude(), Longitude(), UserAccessRight(), soap() { }
        virtual ~ns__StationInfo() { }
        /// Friend allocator used by soap_new_ns__StationInfo(struct soap*, int)
        friend SOAP_FMAC1 ns__StationInfo * SOAP_FMAC2 soap_instantiate_ns__StationInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:165 */
#ifndef SOAP_TYPE_ns__UnitInfo
#define SOAP_TYPE_ns__UnitInfo (11)
/* complex XML schema type 'ns:UnitInfo': */
class SOAP_CMAC ns__UnitInfo {
      public:
        /// Required element 'ID' of XML schema type 'xsd:string'
        std::string ID;
        /// Required element 'Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns__UnitInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns__UnitInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__UnitInfo, default initialized and not managed by a soap context
        virtual ns__UnitInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns__UnitInfo); }
      public:
        /// Constructor with default initializations
        ns__UnitInfo() : ID(), Name(), soap() { }
        virtual ~ns__UnitInfo() { }
        /// Friend allocator used by soap_new_ns__UnitInfo(struct soap*, int)
        friend SOAP_FMAC1 ns__UnitInfo * SOAP_FMAC2 soap_instantiate_ns__UnitInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:167 */
#ifndef SOAP_TYPE_ns__SensorInfo
#define SOAP_TYPE_ns__SensorInfo (12)
/* complex XML schema type 'ns:SensorInfo': */
class SOAP_CMAC ns__SensorInfo {
      public:
        /// Required element 'ID' of XML schema type 'xsd:string'
        std::string ID;
        /// Required element 'Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required element 'AveragePeriod' of XML schema type 'xsd:int'
        int AveragePeriod;
        /// Optional element 'Unit' of XML schema type 'ns:UnitInfo'
        ns__UnitInfo *Unit;
        /// Required element 'MeasurClass' of XML schema type 'ns:MeasurementClasses'
        enum ns__MeasurementClasses MeasurClass;
        /// Required element 'StationID' of XML schema type 'xsd:string'
        std::string StationID;
        /// Required element 'IsWeathercock' of XML schema type 'xsd:boolean'
        bool IsWeathercock;
        /// Required element 'PDKValue' of XML schema type 'xsd:double'
        double PDKValue;
        /// Required element 'PDKDayValue' of XML schema type 'xsd:double'
        double PDKDayValue;
        /// Required element 'DefaultColor' of XML schema type 'xsd:int'
        int DefaultColor;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns__SensorInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns__SensorInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__SensorInfo, default initialized and not managed by a soap context
        virtual ns__SensorInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns__SensorInfo); }
      public:
        /// Constructor with default initializations
        ns__SensorInfo() : ID(), Name(), AveragePeriod(), Unit(), MeasurClass(), StationID(), IsWeathercock(), PDKValue(), PDKDayValue(), DefaultColor(), soap() { }
        virtual ~ns__SensorInfo() { }
        /// Friend allocator used by soap_new_ns__SensorInfo(struct soap*, int)
        friend SOAP_FMAC1 ns__SensorInfo * SOAP_FMAC2 soap_instantiate_ns__SensorInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:169 */
#ifndef SOAP_TYPE_ns__SensorData
#define SOAP_TYPE_ns__SensorData (13)
/* complex XML schema type 'ns:SensorData': */
class SOAP_CMAC ns__SensorData {
      public:
        /// Required element 'SensorID' of XML schema type 'xsd:string'
        std::string SensorID;
        /// Optional element 'Data' of XML schema type 'ns:ArrayOfBriefData'
        ns__ArrayOfBriefData *Data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns__SensorData
        virtual long soap_type(void) const { return SOAP_TYPE_ns__SensorData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__SensorData, default initialized and not managed by a soap context
        virtual ns__SensorData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns__SensorData); }
      public:
        /// Constructor with default initializations
        ns__SensorData() : SensorID(), Data(), soap() { }
        virtual ~ns__SensorData() { }
        /// Friend allocator used by soap_new_ns__SensorData(struct soap*, int)
        friend SOAP_FMAC1 ns__SensorData * SOAP_FMAC2 soap_instantiate_ns__SensorData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:171 */
#ifndef SOAP_TYPE_ns__ArrayOfStationInfo
#define SOAP_TYPE_ns__ArrayOfStationInfo (14)
/* complex XML schema type 'ns:ArrayOfStationInfo': */
class SOAP_CMAC ns__ArrayOfStationInfo {
      public:
        /// Optional element 'StationsInfo' of XML schema type 'ns:StationInfo'
        std::vector<ns__StationInfo *> StationsInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns__ArrayOfStationInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns__ArrayOfStationInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ArrayOfStationInfo, default initialized and not managed by a soap context
        virtual ns__ArrayOfStationInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns__ArrayOfStationInfo); }
      public:
        /// Constructor with default initializations
        ns__ArrayOfStationInfo() : StationsInfo(), soap() { }
        virtual ~ns__ArrayOfStationInfo() { }
        /// Friend allocator used by soap_new_ns__ArrayOfStationInfo(struct soap*, int)
        friend SOAP_FMAC1 ns__ArrayOfStationInfo * SOAP_FMAC2 soap_instantiate_ns__ArrayOfStationInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:173 */
#ifndef SOAP_TYPE_ns__ArrayOfSensorsInfo
#define SOAP_TYPE_ns__ArrayOfSensorsInfo (15)
/* complex XML schema type 'ns:ArrayOfSensorsInfo': */
class SOAP_CMAC ns__ArrayOfSensorsInfo {
      public:
        /// Optional element 'SensorsInfo' of XML schema type 'ns:SensorInfo'
        std::vector<ns__SensorInfo *> SensorsInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns__ArrayOfSensorsInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns__ArrayOfSensorsInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ArrayOfSensorsInfo, default initialized and not managed by a soap context
        virtual ns__ArrayOfSensorsInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns__ArrayOfSensorsInfo); }
      public:
        /// Constructor with default initializations
        ns__ArrayOfSensorsInfo() : SensorsInfo(), soap() { }
        virtual ~ns__ArrayOfSensorsInfo() { }
        /// Friend allocator used by soap_new_ns__ArrayOfSensorsInfo(struct soap*, int)
        friend SOAP_FMAC1 ns__ArrayOfSensorsInfo * SOAP_FMAC2 soap_instantiate_ns__ArrayOfSensorsInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:175 */
#ifndef SOAP_TYPE_ns__ArrayOfSensorData
#define SOAP_TYPE_ns__ArrayOfSensorData (16)
/* complex XML schema type 'ns:ArrayOfSensorData': */
class SOAP_CMAC ns__ArrayOfSensorData {
      public:
        /// Optional element 'SensorData' of XML schema type 'ns:SensorData'
        std::vector<ns__SensorData *> SensorData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns__ArrayOfSensorData
        virtual long soap_type(void) const { return SOAP_TYPE_ns__ArrayOfSensorData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ArrayOfSensorData, default initialized and not managed by a soap context
        virtual ns__ArrayOfSensorData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns__ArrayOfSensorData); }
      public:
        /// Constructor with default initializations
        ns__ArrayOfSensorData() : SensorData(), soap() { }
        virtual ~ns__ArrayOfSensorData() { }
        /// Friend allocator used by soap_new_ns__ArrayOfSensorData(struct soap*, int)
        friend SOAP_FMAC1 ns__ArrayOfSensorData * SOAP_FMAC2 soap_instantiate_ns__ArrayOfSensorData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:177 */
#ifndef SOAP_TYPE_ns__StInfo
#define SOAP_TYPE_ns__StInfo (17)
/* complex XML schema type 'ns:StInfo': */
class SOAP_CMAC ns__StInfo {
      public:
        /// Required element 'ID' of XML schema type 'xsd:string'
        std::string ID;
        /// Required element 'Code' of XML schema type 'xsd:int'
        int Code;
        /// Required element 'Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required element 'UpdatePeriod' of XML schema type 'xsd:int'
        int UpdatePeriod;
        /// Required element 'UserAccessRight' of XML schema type 'ns:UserAccessRightCode'
        enum ns__UserAccessRightCode UserAccessRight;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns__StInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns__StInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__StInfo, default initialized and not managed by a soap context
        virtual ns__StInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns__StInfo); }
      public:
        /// Constructor with default initializations
        ns__StInfo() : ID(), Code(), Name(), UpdatePeriod(), UserAccessRight(), soap() { }
        virtual ~ns__StInfo() { }
        /// Friend allocator used by soap_new_ns__StInfo(struct soap*, int)
        friend SOAP_FMAC1 ns__StInfo * SOAP_FMAC2 soap_instantiate_ns__StInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:179 */
#ifndef SOAP_TYPE_ns__ArrayOfSensors
#define SOAP_TYPE_ns__ArrayOfSensors (18)
/* complex XML schema type 'ns:ArrayOfSensors': */
class SOAP_CMAC ns__ArrayOfSensors {
      public:
        /// Optional element 'string' of XML schema type 'xsd:string'
        std::vector<std::string> string;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns__ArrayOfSensors
        virtual long soap_type(void) const { return SOAP_TYPE_ns__ArrayOfSensors; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ArrayOfSensors, default initialized and not managed by a soap context
        virtual ns__ArrayOfSensors *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns__ArrayOfSensors); }
      public:
        /// Constructor with default initializations
        ns__ArrayOfSensors() : string(), soap() { }
        virtual ~ns__ArrayOfSensors() { }
        /// Friend allocator used by soap_new_ns__ArrayOfSensors(struct soap*, int)
        friend SOAP_FMAC1 ns__ArrayOfSensors * SOAP_FMAC2 soap_instantiate_ns__ArrayOfSensors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:596 */
#ifndef SOAP_TYPE_ns__GetStationsResponse
#define SOAP_TYPE_ns__GetStationsResponse (38)
/* complex XML schema type 'ns:GetStationsResponse': */
struct SOAP_CMAC ns__GetStationsResponse {
      public:
        /** Optional element 'GetStationsResult' of XML schema type 'ns:ArrayOfStationInfo' */
        ns__ArrayOfStationInfo *GetStationsResult;
        /** Required element 'ErrorCode' of XML schema type 'ns:ErrorCode' */
        enum ns__ErrorCode ErrorCode;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetStationsResponse */
        long soap_type() const { return SOAP_TYPE_ns__GetStationsResponse; }
        /** Constructor with member initializations */
        ns__GetStationsResponse() : GetStationsResult(), ErrorCode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns__GetStationsResponse * SOAP_FMAC2 soap_instantiate_ns__GetStationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:662 */
#ifndef SOAP_TYPE_ns__GetStations
#define SOAP_TYPE_ns__GetStations (42)
/* complex XML schema type 'ns:GetStations': */
struct SOAP_CMAC ns__GetStations {
      public:
        /** Required element 'login' of XML schema type 'xsd:string' */
        std::string login;
        /** Required element 'password' of XML schema type 'xsd:string' */
        std::string password;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetStations */
        long soap_type() const { return SOAP_TYPE_ns__GetStations; }
        /** Constructor with member initializations */
        ns__GetStations() : login(), password() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns__GetStations * SOAP_FMAC2 soap_instantiate_ns__GetStations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:673 */
#ifndef SOAP_TYPE_ns__GetSensorsResponse
#define SOAP_TYPE_ns__GetSensorsResponse (43)
/* complex XML schema type 'ns:GetSensorsResponse': */
struct SOAP_CMAC ns__GetSensorsResponse {
      public:
        /** Optional element 'GetSensorsResult' of XML schema type 'ns:ArrayOfSensorsInfo' */
        ns__ArrayOfSensorsInfo *GetSensorsResult;
        /** Required element 'ErrorCode' of XML schema type 'ns:ErrorCode' */
        enum ns__ErrorCode ErrorCode;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetSensorsResponse */
        long soap_type() const { return SOAP_TYPE_ns__GetSensorsResponse; }
        /** Constructor with member initializations */
        ns__GetSensorsResponse() : GetSensorsResult(), ErrorCode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns__GetSensorsResponse * SOAP_FMAC2 soap_instantiate_ns__GetSensorsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:748 */
#ifndef SOAP_TYPE_ns__GetSensors
#define SOAP_TYPE_ns__GetSensors (47)
/* complex XML schema type 'ns:GetSensors': */
struct SOAP_CMAC ns__GetSensors {
      public:
        /** Required element 'login' of XML schema type 'xsd:string' */
        std::string login;
        /** Required element 'password' of XML schema type 'xsd:string' */
        std::string password;
        /** Required element 'StationID' of XML schema type 'xsd:string' */
        std::string StationID;
        /** Required element 'From' of XML schema type 'xsd:string' */
        std::string From;
        /** Required element 'To' of XML schema type 'xsd:string' */
        std::string To;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetSensors */
        long soap_type() const { return SOAP_TYPE_ns__GetSensors; }
        /** Constructor with member initializations */
        ns__GetSensors() : login(), password(), StationID(), From(), To() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns__GetSensors * SOAP_FMAC2 soap_instantiate_ns__GetSensors(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:759 */
#ifndef SOAP_TYPE_ns__GetHistoricalDataBriefResponse
#define SOAP_TYPE_ns__GetHistoricalDataBriefResponse (48)
/* complex XML schema type 'ns:GetHistoricalDataBriefResponse': */
struct SOAP_CMAC ns__GetHistoricalDataBriefResponse {
      public:
        /** Optional element 'GetHistoricalDataBriefResult' of XML schema type 'ns:ArrayOfSensorData' */
        ns__ArrayOfSensorData *GetHistoricalDataBriefResult;
        /** Required element 'ErrorCode' of XML schema type 'ns:ErrorCode' */
        enum ns__ErrorCode ErrorCode;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetHistoricalDataBriefResponse */
        long soap_type() const { return SOAP_TYPE_ns__GetHistoricalDataBriefResponse; }
        /** Constructor with member initializations */
        ns__GetHistoricalDataBriefResponse() : GetHistoricalDataBriefResult(), ErrorCode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns__GetHistoricalDataBriefResponse * SOAP_FMAC2 soap_instantiate_ns__GetHistoricalDataBriefResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:837 */
#ifndef SOAP_TYPE_ns__GetHistoricalDataBrief
#define SOAP_TYPE_ns__GetHistoricalDataBrief (53)
/* complex XML schema type 'ns:GetHistoricalDataBrief': */
struct SOAP_CMAC ns__GetHistoricalDataBrief {
      public:
        /** Required element 'login' of XML schema type 'xsd:string' */
        std::string login;
        /** Required element 'password' of XML schema type 'xsd:string' */
        std::string password;
        /** Required element 'AveragePeriod' of XML schema type 'xsd:int' */
        int AveragePeriod;
        /** Optional element 'sSensors' of XML schema type 'ns:ArrayOfSensors' */
        ns__ArrayOfSensors *sSensors;
        /** Required element 'From' of XML schema type 'xsd:string' */
        std::string From;
        /** Required element 'To' of XML schema type 'xsd:string' */
        std::string To;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetHistoricalDataBrief */
        long soap_type() const { return SOAP_TYPE_ns__GetHistoricalDataBrief; }
        /** Constructor with member initializations */
        ns__GetHistoricalDataBrief() : login(), password(), AveragePeriod(), sSensors(), From(), To() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns__GetHistoricalDataBrief * SOAP_FMAC2 soap_instantiate_ns__GetHistoricalDataBrief(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* test.h:898 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (54)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* test.h:898 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (55)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* test.h:898 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (57)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* test.h:898 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (60)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* test.h:898 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (61)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (27)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (23)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (29)
#endif

/* enum ns__MeasurementClasses has binding name 'ns__MeasurementClasses' for type 'ns:MeasurementClasses' */
#ifndef SOAP_TYPE_ns__MeasurementClasses
#define SOAP_TYPE_ns__MeasurementClasses (21)
#endif

/* enum ns__UserAccessRightCode has binding name 'ns__UserAccessRightCode' for type 'ns:UserAccessRightCode' */
#ifndef SOAP_TYPE_ns__UserAccessRightCode
#define SOAP_TYPE_ns__UserAccessRightCode (20)
#endif

/* enum ns__ErrorCode has binding name 'ns__ErrorCode' for type 'ns:ErrorCode' */
#ifndef SOAP_TYPE_ns__ErrorCode
#define SOAP_TYPE_ns__ErrorCode (19)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (22)
#endif

/* ns__ArrayOfSensors has binding name 'ns__ArrayOfSensors' for type 'ns:ArrayOfSensors' */
#ifndef SOAP_TYPE_ns__ArrayOfSensors
#define SOAP_TYPE_ns__ArrayOfSensors (18)
#endif

/* ns__StInfo has binding name 'ns__StInfo' for type 'ns:StInfo' */
#ifndef SOAP_TYPE_ns__StInfo
#define SOAP_TYPE_ns__StInfo (17)
#endif

/* ns__ArrayOfSensorData has binding name 'ns__ArrayOfSensorData' for type 'ns:ArrayOfSensorData' */
#ifndef SOAP_TYPE_ns__ArrayOfSensorData
#define SOAP_TYPE_ns__ArrayOfSensorData (16)
#endif

/* ns__ArrayOfSensorsInfo has binding name 'ns__ArrayOfSensorsInfo' for type 'ns:ArrayOfSensorsInfo' */
#ifndef SOAP_TYPE_ns__ArrayOfSensorsInfo
#define SOAP_TYPE_ns__ArrayOfSensorsInfo (15)
#endif

/* ns__ArrayOfStationInfo has binding name 'ns__ArrayOfStationInfo' for type 'ns:ArrayOfStationInfo' */
#ifndef SOAP_TYPE_ns__ArrayOfStationInfo
#define SOAP_TYPE_ns__ArrayOfStationInfo (14)
#endif

/* ns__SensorData has binding name 'ns__SensorData' for type 'ns:SensorData' */
#ifndef SOAP_TYPE_ns__SensorData
#define SOAP_TYPE_ns__SensorData (13)
#endif

/* ns__SensorInfo has binding name 'ns__SensorInfo' for type 'ns:SensorInfo' */
#ifndef SOAP_TYPE_ns__SensorInfo
#define SOAP_TYPE_ns__SensorInfo (12)
#endif

/* ns__UnitInfo has binding name 'ns__UnitInfo' for type 'ns:UnitInfo' */
#ifndef SOAP_TYPE_ns__UnitInfo
#define SOAP_TYPE_ns__UnitInfo (11)
#endif

/* ns__StationInfo has binding name 'ns__StationInfo' for type 'ns:StationInfo' */
#ifndef SOAP_TYPE_ns__StationInfo
#define SOAP_TYPE_ns__StationInfo (10)
#endif

/* ns__ArrayOfBriefData has binding name 'ns__ArrayOfBriefData' for type 'ns:ArrayOfBriefData' */
#ifndef SOAP_TYPE_ns__ArrayOfBriefData
#define SOAP_TYPE_ns__ArrayOfBriefData (9)
#endif

/* ns__BriefData has binding name 'ns__BriefData' for type 'ns:BriefData' */
#ifndef SOAP_TYPE_ns__BriefData
#define SOAP_TYPE_ns__BriefData (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (61)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (60)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (57)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (55)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (54)
#endif

/* struct ns__GetHistoricalDataBrief has binding name 'ns__GetHistoricalDataBrief' for type 'ns:GetHistoricalDataBrief' */
#ifndef SOAP_TYPE_ns__GetHistoricalDataBrief
#define SOAP_TYPE_ns__GetHistoricalDataBrief (53)
#endif

/* struct ns__GetHistoricalDataBriefResponse has binding name 'ns__GetHistoricalDataBriefResponse' for type 'ns:GetHistoricalDataBriefResponse' */
#ifndef SOAP_TYPE_ns__GetHistoricalDataBriefResponse
#define SOAP_TYPE_ns__GetHistoricalDataBriefResponse (48)
#endif

/* struct ns__GetSensors has binding name 'ns__GetSensors' for type 'ns:GetSensors' */
#ifndef SOAP_TYPE_ns__GetSensors
#define SOAP_TYPE_ns__GetSensors (47)
#endif

/* struct ns__GetSensorsResponse has binding name 'ns__GetSensorsResponse' for type 'ns:GetSensorsResponse' */
#ifndef SOAP_TYPE_ns__GetSensorsResponse
#define SOAP_TYPE_ns__GetSensorsResponse (43)
#endif

/* struct ns__GetStations has binding name 'ns__GetStations' for type 'ns:GetStations' */
#ifndef SOAP_TYPE_ns__GetStations
#define SOAP_TYPE_ns__GetStations (42)
#endif

/* struct ns__GetStationsResponse has binding name 'ns__GetStationsResponse' for type 'ns:GetStationsResponse' */
#ifndef SOAP_TYPE_ns__GetStationsResponse
#define SOAP_TYPE_ns__GetStationsResponse (38)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (63)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (62)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (56)
#endif

/* ns__ArrayOfSensors * has binding name 'PointerTons__ArrayOfSensors' for type 'ns:ArrayOfSensors' */
#ifndef SOAP_TYPE_PointerTons__ArrayOfSensors
#define SOAP_TYPE_PointerTons__ArrayOfSensors (50)
#endif

/* ns__ArrayOfSensorData * has binding name 'PointerTons__ArrayOfSensorData' for type 'ns:ArrayOfSensorData' */
#ifndef SOAP_TYPE_PointerTons__ArrayOfSensorData
#define SOAP_TYPE_PointerTons__ArrayOfSensorData (49)
#endif

/* ns__ArrayOfSensorsInfo * has binding name 'PointerTons__ArrayOfSensorsInfo' for type 'ns:ArrayOfSensorsInfo' */
#ifndef SOAP_TYPE_PointerTons__ArrayOfSensorsInfo
#define SOAP_TYPE_PointerTons__ArrayOfSensorsInfo (44)
#endif

/* ns__ArrayOfStationInfo * has binding name 'PointerTons__ArrayOfStationInfo' for type 'ns:ArrayOfStationInfo' */
#ifndef SOAP_TYPE_PointerTons__ArrayOfStationInfo
#define SOAP_TYPE_PointerTons__ArrayOfStationInfo (39)
#endif

/* ns__SensorData * has binding name 'PointerTons__SensorData' for type 'ns:SensorData' */
#ifndef SOAP_TYPE_PointerTons__SensorData
#define SOAP_TYPE_PointerTons__SensorData (35)
#endif

/* ns__SensorInfo * has binding name 'PointerTons__SensorInfo' for type 'ns:SensorInfo' */
#ifndef SOAP_TYPE_PointerTons__SensorInfo
#define SOAP_TYPE_PointerTons__SensorInfo (33)
#endif

/* ns__StationInfo * has binding name 'PointerTons__StationInfo' for type 'ns:StationInfo' */
#ifndef SOAP_TYPE_PointerTons__StationInfo
#define SOAP_TYPE_PointerTons__StationInfo (31)
#endif

/* ns__ArrayOfBriefData * has binding name 'PointerTons__ArrayOfBriefData' for type 'ns:ArrayOfBriefData' */
#ifndef SOAP_TYPE_PointerTons__ArrayOfBriefData
#define SOAP_TYPE_PointerTons__ArrayOfBriefData (30)
#endif

/* ns__UnitInfo * has binding name 'PointerTons__UnitInfo' for type 'ns:UnitInfo' */
#ifndef SOAP_TYPE_PointerTons__UnitInfo
#define SOAP_TYPE_PointerTons__UnitInfo (28)
#endif

/* ns__BriefData * has binding name 'PointerTons__BriefData' for type 'ns:BriefData' */
#ifndef SOAP_TYPE_PointerTons__BriefData
#define SOAP_TYPE_PointerTons__BriefData (25)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (37)
#endif

/* std::vector<ns__SensorData *>  has binding name 'std__vectorTemplateOfPointerTons__SensorData' for type 'ns:SensorData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons__SensorData
#define SOAP_TYPE_std__vectorTemplateOfPointerTons__SensorData (36)
#endif

/* std::vector<ns__SensorInfo *>  has binding name 'std__vectorTemplateOfPointerTons__SensorInfo' for type 'ns:SensorInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons__SensorInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerTons__SensorInfo (34)
#endif

/* std::vector<ns__StationInfo *>  has binding name 'std__vectorTemplateOfPointerTons__StationInfo' for type 'ns:StationInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons__StationInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerTons__StationInfo (32)
#endif

/* std::vector<ns__BriefData *>  has binding name 'std__vectorTemplateOfPointerTons__BriefData' for type 'ns:BriefData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons__BriefData
#define SOAP_TYPE_std__vectorTemplateOfPointerTons__BriefData (26)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    
    /** Web service synchronous operation 'soap_call_ns__GetStations' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetStations(struct soap *soap, const char *soap_endpoint, const char *soap_action, const std::string& login, const std::string& password, struct ns__GetStationsResponse &_param_1);
    /** Web service asynchronous operation 'soap_send_ns__GetStations' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send_ns__GetStations(struct soap *soap, const char *soap_endpoint, const char *soap_action, const std::string& login, const std::string& password);
    /** Web service asynchronous operation 'soap_recv_ns__GetStations' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv_ns__GetStations(struct soap *soap, struct ns__GetStationsResponse &_param_1);
    
    /** Web service synchronous operation 'soap_call_ns__GetSensors' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetSensors(struct soap *soap, const char *soap_endpoint, const char *soap_action, const std::string& login, const std::string& password, const std::string& StationID, const std::string& From, const std::string& To, struct ns__GetSensorsResponse &_param_1);
    /** Web service asynchronous operation 'soap_send_ns__GetSensors' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send_ns__GetSensors(struct soap *soap, const char *soap_endpoint, const char *soap_action, const std::string& login, const std::string& password, const std::string& StationID, const std::string& From, const std::string& To);
    /** Web service asynchronous operation 'soap_recv_ns__GetSensors' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv_ns__GetSensors(struct soap *soap, struct ns__GetSensorsResponse &_param_1);
    
    /** Web service synchronous operation 'soap_call_ns__GetHistoricalDataBrief' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__GetHistoricalDataBrief(struct soap *soap, const char *soap_endpoint, const char *soap_action, const std::string& login, const std::string& password, int AveragePeriod, ns__ArrayOfSensors *sSensors, const std::string& From, const std::string& To, struct ns__GetHistoricalDataBriefResponse &_param_1);
    /** Web service asynchronous operation 'soap_send_ns__GetHistoricalDataBrief' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send_ns__GetHistoricalDataBrief(struct soap *soap, const char *soap_endpoint, const char *soap_action, const std::string& login, const std::string& password, int AveragePeriod, ns__ArrayOfSensors *sSensors, const std::string& From, const std::string& To);
    /** Web service asynchronous operation 'soap_recv_ns__GetHistoricalDataBrief' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv_ns__GetHistoricalDataBrief(struct soap *soap, struct ns__GetHistoricalDataBriefResponse &_param_1);

#endif

/* End of soapStub.h */
